#!/usr/bin/python

import subprocess
import os
import re
import sys

NONE = 0
GUITARTEX = 1
CHORDII = 2
which_typesetter = GUITARTEX
# which_typesetter = CHORDII
guitartex_multicol = True

chordpro_htmls = [
    "and_she_was.chopro.html",
    # "anyone_else_but_you.chopro.html",
    "burning_for_you.chopro.html",
    "christians_and_pagans.chopro.html",
    "clocks.chopro.html",
    "comfortably_numb.chopro.html",
    "coming_up_close.chopro.html",
    # "crazy_on_you_2.chopro.html",
    # "crazy_on_you_3.chopro.html",
    # "crazy_on_you.chopro.html",
    "cruel_to_be_kind.chopro.html",
    "dead_flowers.chopro.html",
    "donald_wheres_your_trousers.chopro.html",
    "down_by_the_river.chopro.html",
    "down_under.chopro.html",
    "flagpole_sitta.chopro.html",
    "folsom_prison_blues.chopro.html",
    "gold_dust_woman.chopro.html",
    "heart_of_gold.chopro.html",
    "hey_there_delilah.chopro.html",
    "high_and_dry.chopro.html",
    "horse.chopro.html",
    "horse_with_no_name.chopro.html",
    "hotel_california.chopro.html",
    "im_in.chopro.html",
    "in_between_days.chopro.html",
    "island_in_the_sun.chopro.html",
    "last_train_to_clarksville.chopro.html",
    "learning_to_fly.chopro.html",
    "let_her_cry.chopro.html",
    "lithium.chopro.html",
    "lola.chopro.html",
    "man_of_constant_sorrow.chopro.html",
    "mary_janes_last_dance.chopro.html",
    "my_sweet_annette.chopro.html",
    "need_you_now.chopro.html",
    "no_rain.chopro.html",
    "norwegian_wood.chopro.html",
    "one.chopro.html",
    "patience.chopro.html",
    "peaceful_easy_feeling.chopro.html",
    "ring_of_fire.chopro.html",
    "service_and_repair.chopro.html",
    "stuck_in_the_middle_with_you.chopro.html",
    "soul_meets_body.chopro.html",
    "southern_cross.chopro.html",
    "sundown.chopro.html",
    "sweet_child_of_mine.chopro.html",
    "too_late_for_love.chopro.html",
    "walk_on_the_ocean.chopro.html",
    "wasted_on_the_way.chopro.html",
    "wish_it_would_rain.chopro.html",
    "wish_you_were_here.chopro.html",
    "wonderwall.chopro.html",
    "yer_so_bad.chopro.html",
    "zombie_cranberries.chopro.html",
]

chordpro_files = []

comment_re = re.compile(r"[     ]*#.*")
# comment_re = re.compile(r"#")
define_re = re.compile(r"\{define:\s*(?P<name>[()#/\w]+)\s+(?P<E>[ox\d])\s+(?P<A>[ox\d])\s+(?P<D>[ox\d])\s+(?P<G>[ox\d])\s+(?P<b>[ox\d])\s+(?P<e>[ox\d])")
# {define:Fmaj7 1 0 3 2 1 x}
columns_re = re.compile(r"\{columns:[   ]*(?P<columns>[0-9]+)")

def make_chordii(filename, source_lines):

    chordpro_lines = []

    for line in source_lines:

        if comment_re.match(line):
            print "skipping commented line '%s'" % line
            next

        elif (line.find("{colb}") == 0) or (line.find("{columnbreak}") >= 0):

            if chordpro_lines[0] != '{columns: 2}':
                chordpro_lines.insert(0, '{columns: 2}')
            chordpro_lines.append(line)

        elif (line.find("{define:") >= 0):

            # change define syntax
            match = define_re.search(line)

            if not match:

                print >>sys.stderr, "warning, didn't parse chord definition '%s', passing through" % line
                chordpro_lines.append(line)

            else:
                group = match.group
                frets = [group(fret) for fret in ['E', 'A', 'D', 'G', 'b', 'e']]
                minfret = min([int(fret) for fret in frets if fret not in ['x', 'X', 'o', 'O']])
                if minfret < 3:
                    minfret = 1
                # revfrets = reversed(frets)
                # new_define = "{define:%s %s %s}" % (group('name'), minfret, " ".join(revfrets))

                frets = [fret.replace('0', 'o') for fret in frets]
                new_define = "{define:%s %s %s}" % (group('name'), minfret, " ".join(frets))
                chordpro_lines.append(new_define)

        elif ((line.find("{pagebreak}") >= 0) or (line.find("{pageb}") >= 0) or
            (line.find("{np}") >= 0)):

            # the directive known by chordii is actually "new_page".

            chordpro_lines.append("{new_page}")
            where = len(chordpro_lines)

        else:
            chordpro_lines.append(line)

    return chordpro_lines

def make_guitartex(filename, source_lines):
    where = 0
    in_multicol_mode = False

    chordpro_lines = []

    for line in source_lines:
        if comment_re.match(line):
            next

        elif (line.find("{define:") >= 0):

            # change define syntax
            match = define_re.search(line)

            if not match:

                print >>sys.stderr, "warning, didn't parse chord definition '%s', passing through" % line
                chordpro_lines.append(line)

            else:
                group = match.group
                frets = [group(fret) for fret in ['E', 'A', 'D', 'G', 'b', 'e']]
                minfret = min([int(fret) for fret in frets if fret not in ['x', 'X', 'o', 'O']])
                if minfret < 3:
                    minfret = 1
                # revfrets = reversed(frets)
                # new_define = "{define:%s %s %s}" % (group('name'), minfret, " ".join(revfrets))

                frets = [fret.replace('0', 'o') for fret in frets]
                new_define = "{define:%s %s %s}" % (group('name'), minfret, " ".join(frets))
                chordpro_lines.append(new_define)

        elif ((line.find("{t:") >= 0) or (line.find("{title:") >= 0) or
            (line.find("{st:") >= 0) or (line.find("{subtitle:") >= 0)):

            chordpro_lines.append(line)
            where = len(chordpro_lines)

        elif (line.find("{colb}") >= 0) or (line.find("{columnbreak}") >= 0):

            if not in_multicol_mode:

                # assume two columns
                chordpro_lines.insert(where, "\\begin{multicols}{2}")
                in_multicol_mode = True

            chordpro_lines.append("\\columnbreak")

        elif (line.find("{columns:") >= 0):

            if not in_multicol_mode:

                match = columns_re.search(line)
                if not match:
                    print >>sys.stderr, "couldn't parse columns directive in %s at line '%s'" % (filename, line)
                    sys.exit(1)

                columns = int(match.group('columns'))
                chordpro_lines.insert(where, "\\begin{multicols}{%d}" % columns)
                in_multicol_mode = True

            else:
                print >>sys.stderr, "two column directives seen in %s" % filename
                sys.exit(1)

        elif ((line.find("{pagebreak}") >= 0) or (line.find("{pageb}") >= 0) or
            (line.find("{np}") >= 0)):

            # the directive known by guitartex is actually "np".

            if in_multicol_mode:
                chordpro_lines.append("\\end{multicols}")
                in_multicol_mode = False

            chordpro_lines.append("{np}")
            where = len(chordpro_lines)

        else:
            chordpro_lines.append(line)

    if in_multicol_mode:
        chordpro_lines.append("\\end{multicols}")

    return chordpro_lines

if False:
    lines = [
    '{define:Fmaj7 1 0 3 2 1 x}'
    ]
    out = make_guitartex("test_file", lines)
    for line in out:
        print line
    sys.exit(0)

if False:
    lines = [
    '{title:the love boat}',
    '{subtitle:who knows}',
    'the love boat',
    'soon will be making another run',
    'the love boat',
    '{colb}',
    'soon will be taking off your pants',
    '{np}',
    'its your thing',
    'do what you wanna do',
    '{colb}',
    'I cant tell you',
    'who to sock it to',
    ]
    out = make_guitartex("test_file", lines)
    for line in out:
        print line
    sys.exit(0)

for html in chordpro_htmls:
    source = "./" + html
    chordpro = "guitartex/" + html.replace(".html", "")
    chordpro_files.append(chordpro)

    source_date = os.path.getmtime(source)
    chordpro_exists = os.path.exists(chordpro)
    if chordpro_exists:
        chordpro_date = os.path.getmtime(chordpro)

    if chordpro_exists and (source_date < chordpro_date):
        print "%s is later than source file, skipping\n" % chordpro
        pass
    else:
        source_file = open(source, "r")

        instance = subprocess.Popen(args = "html2txt", stdin=source_file, stdout=subprocess.PIPE)
        source_lines = [line.rstrip() for line in instance.stdout]
        result = instance.wait()
        source_file.close()
        if result != 0:
            print "failed with %d on %s\n" % (result, chordpro)
            sys.exit(1)

        if which_typesetter == GUITARTEX:
            chordpro_lines = make_guitartex(source, source_lines)
        elif which_typesetter == CHORDII:
            chordpro_lines = make_chordii(source, source_lines)

        chordpro_file = open(chordpro, "w")
        print >>chordpro_file, "\n".join(chordpro_lines)
        chordpro_file.close()
   
if which_typesetter == CHORDII:

    allsongs = open("chopro/allsongs.chopro", "w")
    firstsong = True

    for chordpro in chordpro_files:

        chordpro_file = open(chordpro)
        buffer = chordpro_file.read()
        chordpro_file.close()

        if not firstsong:
            # print >>allsongs, "\n{new_page}\n"
            print >>allsongs, "\n{new_song}\n"
        allsongs.write(buffer)

        firstsong = False

    allsongs.close()

elif which_typesetter == GUITARTEX:

    allsongs = open("songbook.chopro", "w")

    if guitartex_multicol:
        print >>allsongs, "{preamble:\usepackage{multicol}}"

    print >> allsongs, "{document_class:book}"

    # This results in a TeX error!
    # print >> allsongs, "{geometry:letterpaper,margin=.75in}"
    print >> allsongs, "{geometry:margin=.75in}"
    # print >> allsongs, "{font_size:10}"
    # black and white printing:
    print >> allsongs, "{color_chorus:.3,.3,.3}"

    print >> allsongs, "{book_title:Jamcrowd Songbook, Karma Chickens Edition}"
    print >> allsongs, "{book_date:September 2010}"

    for chordpro in chordpro_files:
        print >> allsongs, "{include:%s}" % chordpro

    allsongs.close()
